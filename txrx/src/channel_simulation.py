import numpy as np
from pyfftw.interfaces.numpy_fft import fft,ifft
from einops import rearrange, repeat


def extract_CIR(data, spb, pilot):
	impulse = pilot.size
	assert data.size % (spb * impulse) == 0
	data_arrange =  rearrange(data, '(rep impulse spb) ch -> rep (impulse spb) ch', spb=spb, impulse=impulse)
	# each rep stands for impulse*spb length!
	pilot_upsample_h =  repeat(fft(pilot, n=impulse), 'P -> (spb P)', spb=spb).reshape([1, -1, 1])
	return ifft(fft(data_arrange, axis=1) / pilot_upsample_h, axis=1)

def simulated_channel(spb, cirblk, bits):
	'''
	Input the CIR, convolve the bits (assuming +-1, upsample as impulse) with the channel,
	add noise by SNR and return.

	:param spb:  sample per bit
	:param cir: generated by extract_CIR
	:param bits: BPSK +-1 symbols
	:return: The simulated received signal
	'''
	rep, impulse_spb, ch = cirblk.shape
	assert rep * impulse_spb >= bits.size
	assert impulse_spb % spb == 0;
	impulse = impulse_spb // spb
	steps = (bits.size + impulse - 1) // impulse
	output = np.zeros(((bits.size - 1) * spb + impulse_spb, ch), dtype=np.complex64)
	# overlap add, overlap array directly in the output
	N = impulse_spb * 2
	N0 = impulse * 2
	def output_block(i):
		# at last block the (i+1)*impulse could overflow and select less than requested
		# zero padding is done inside the FFT because the FFT is requested to output N0 length
		bits_seg = bits[i * impulse : (i+1)*impulse]
		BITS_SEG = repeat(fft(bits_seg, n=N0), 'P -> (spb P)', spb=spb).reshape([-1, 1]); # N, ch
		return ifft(BITS_SEG * fft(cirblk[i,:,:], axis=0, n=N), axis=0, n=N)
	for i in range(steps - 1):
		output[i * impulse_spb : (i + 2) * impulse_spb, :] += output_block(i)
	last_pos =  (steps - 1) * impulse_spb
	if (output.shape[0]  > last_pos):
		output[last_pos : , :] += output_block(steps - 1)[: output.shape[0] - last_pos, :]
	return output